#!/bin/bash
# bunch of commmands to make cute prompt

# turns the #123b84 color codes to 203;133;54 rgb codes
hex_color_to_rgb() {
    local hex=${1#"#"}
    local r=$((0x${hex:0:2}))
    local g=$((0x${hex:2:2}))
    local b=$((0x${hex:4:2}))
    printf "%d;%d;%d" "$r" "$g" "$b"
}

rgb_ps1() {
    main=${1%,*}
    accent=${1#*,}

    # u=uniform, main is bg, accent is fg no arrow
    if [ "$2" == "u" ]; then
        printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m\]"
    # a=arrow, start with indended arrow, main is bg, accent is fg
    elif [ "$2" == "a" ]; then
        printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "00000");48;2;$(hex_color_to_rgb "$main")m\]\[\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m\]"
    # ab=arrow + bold
    elif [ "$2" == "ab" ]; then
        printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "00000");48;2;$(hex_color_to_rgb "$main")m\]\[\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main");1m\]"
    # f=forground, main is forground, bg is not set
    elif [ "$2" = "f" ]; then
        printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "$main")m\]"
    # s=stop, reset the colors
    elif [ "$1" == "s" ]; then
        printf "\[\033[0m\]"
    fi
}

# Same as rgb_ps1, but without \[ \] escapes (for normal echo output)
rgb_raw() {
    main=${1%,*}
    accent=${1#*,}

    if [ "$2" == "u" ]; then
        printf "\033[0m\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m"
    elif [ "$2" == "a" ]; then
        printf "\033[0m\033[38;2;$(hex_color_to_rgb "000000");48;2;$(hex_color_to_rgb "$main")m\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m"
    elif [ "$2" == "ab" ]; then
        printf "\033[0m\033[38;2;$(hex_color_to_rgb "000000");48;2;$(hex_color_to_rgb "$main")m\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main");1m"
    elif [ "$2" = "f" ]; then
        printf "\033[0m\033[38;2;$(hex_color_to_rgb "$main")m"
    elif [ "$1" == "s" ]; then
        printf "\033[0m"
    fi
}

# Palette Loader
PALETTE_FILE="$HOME/.bash_palettes"
DEFAULT_PALETTE="DEFAULT"

load_palette() {
    local selection
    if [ -f "$PALETTE_FILE" ]; then
        # choose a random non-comment line
        selection=$(grep -v '^#' "$PALETTE_FILE" | grep -v '^\s*$' | shuf -n 1)
    fi

    # If something went wrong, fallback to default
    if [ -z "$selection" ]; then
        selection=$(grep "^${DEFAULT_PALETTE}=" "$PALETTE_FILE" | head -n1)
    fi

    # Parse the chosen palette
    local palette_values=$(echo "$selection" | cut -d'=' -f2 | tr -d '"')
    IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"

    export col_1 col_2 col_3 col_4
}

# Manual override alias
alias d='export FORCE_PALETTE="DEFAULT"; source ~/.bash_prompt'
# Chaos alias
alias ff='unset FORCE_PALETTE; source ~/.bash_prompt'

# --- Show all palettes with color preview ---
ffshow() {
    local file="$HOME/.bash_palettes"

    local original_col_1=$col_1
    local original_col_2=$col_2
    local original_col_3=$col_3
    local original_col_4=$col_4

    # Fake context for preview
    local preview_env="${ENV:-☕ LOCAL}"
    local preview_conda="conda_env"
    local preview_pwd="/Users/me/projects/bash"
    local preview_shortpwd="~/p/bash"
    local preview_branch="main"

    while IFS='=' read -r name value; do
        [[ "$name" =~ ^#|^$ ]] && continue
        name=$(echo "$name" | xargs)
        local palette_values
        palette_values=$(echo "$value" | tr -d '"')
        IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"

        # Build preview lines using your existing rgb_ps1
        local LINE_1 LINE_2
        LINE_1="$(rgb_raw $col_1 'f')╭──$(rgb_raw $col_1 'u') ::$preview_conda:: $(rgb_raw $col_1 'f')\
$(rgb_raw $col_2 'ab') $preview_env $(rgb_raw $col_2 'f')\
$(rgb_raw $col_3 'a') $preview_shortpwd $(rgb_raw $col_3 'f')\
$(rgb_raw $col_4 'a')  $preview_branch $(rgb_raw 's')"
        LINE_2="$(rgb_raw $col_1 'f')╰─ >>> $(rgb_raw 's')"

        echo -e "${LINE_1}\n${LINE_2}   [$name]"
        echo
    done < "$file"

    # Restore original palette
    export col_1=$original_col_1
    export col_2=$original_col_2
    export col_3=$original_col_3
    export col_4=$original_col_4

    echo -e "\033[0m"
}

# --- Pick and activate a specific palette ---
ffpick() {
    local file="$HOME/.bash_palettes"
    local target="$1"
    if [ -z "$target" ]; then
        echo "Usage: prompt-pick <PALETTE_NAME>"
        return 1
    fi
    local line
    line=$(grep "^${target}=" "$file" 2>/dev/null)
    if [ -z "$line" ]; then
        echo "Palette '$target' not found."
        return 1
    fi

    local palette_values
    palette_values=$(echo "$line" | cut -d'=' -f2 | tr -d '"')
    IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"

    export FORCE_PALETTE="$target"
    export col_1 col_2 col_3 col_4

    source ~/.bash_prompt
}

if [ -n "$FORCE_PALETTE" ]; then
    # Load forced palette
    selection=$(grep "^${FORCE_PALETTE}=" "$PALETTE_FILE" | head -n1)
    palette_values=$(echo "$selection" | cut -d'=' -f2 | tr -d '"')
    IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"
else
    load_palette
fi

# -- THE command --
prompt_cmd() {
    local GIT_BRANCH="$(git branch --show-current 2>/dev/null)"
    local CONDA_ENV="$(echo $CONDA_DEFAULT_ENV | awk -F '/' '{print $NF}')"

    # git dirty check (fast)
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        git diff --quiet 2>/dev/null || GIT_DIRTY="*"
    else
        GIT_DIRTY=""
    fi

    local SHORT_PWD="$(echo ${PWD%\/*} | sed -r 's|/(..)[^/]*|/\1|g')"
    local CURRENT_DIR="$(echo ${PWD##*\/})"

    # if in a screen, no color for you
    if [ -n "$STY" ]; then
        LINE_1="╭── ::$CONDA_ENV:: | $ENV | $PWD"
        LINE_2="╰─ >>> "
        [ -n "$GIT_BRANCH" ] && LINE_1="$LINE_1 |  $GIT_BRANCH$GIT_DIRTY"
        PS1="\r\n${LINE_1}\r\n${LINE_2}"
        return
    fi


    # Plently of colors!
    LINE_1="$(rgb_ps1 $col_1 'f')╭──$(rgb_ps1 $col_1 'u') ::$CONDA_ENV:: $(rgb_ps1 $col_1 'f')$(rgb_ps1 $col_2 'ab') $ENV $(rgb_ps1 $col_2 'f')$(rgb_ps1 $col_3 'a') $SHORT_PWD/$CURRENT_DIR $(rgb_ps1 $col_3 'f')"

    if [ -n "$GIT_BRANCH" ]; then
        LINE_1="$LINE_1$(rgb_ps1 $col_4 'a')  $GIT_BRANCH$GIT_DIRTY $(rgb_ps1 's')"
    else
        LINE_1="$LINE_1$(rgb_ps1 's')"
    fi

    LINE_2="$(rgb_ps1 $col_1 'f')╰─ >>> $(rgb_ps1 's')"

    PS1="\r\n${LINE_1}\r\n${LINE_2}"
}

export PROMPT_COMMAND='prompt_cmd'
