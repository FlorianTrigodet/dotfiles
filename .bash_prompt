#!/bin/bash
# Custom aesthetic Bash prompt with dynamic color palettes

### ───────────────────────────────
###  COLOR HELPERS
### ───────────────────────────────

# Convert #RRGGBB to RGB triple (e.g. "255;128;64")
hex_color_to_rgb() {
    local hex=${1#"#"}
    local r=$((0x${hex:0:2}))
    local g=$((0x${hex:2:2}))
    local b=$((0x${hex:4:2}))
    printf "%d;%d;%d" "$r" "$g" "$b"
}

# Produce PS1-safe ANSI color sequences (escaped with \[ \])
rgb_ps1() {
    main=${1%,*}
    accent=${1#*,}

    case "$2" in
        u)  printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m\]" ;;
        a)  printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "000000");48;2;$(hex_color_to_rgb "$main")m\]\[\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m\]" ;;
        ab) printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "000000");48;2;$(hex_color_to_rgb "$main")m\]\[\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main");1m\]" ;;
        f)  printf "\[\033[0m\]\[\033[38;2;$(hex_color_to_rgb "$main")m\]" ;;
        s)  printf "\[\033[0m\]" ;;
    esac
}

# Same, but without Bash \[ \] escapes — used for palette previews
rgb_raw() {
    main=${1%,*}
    accent=${1#*,}

    case "$2" in
        u)  printf "\033[0m\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m" ;;
        a)  printf "\033[0m\033[38;2;$(hex_color_to_rgb "000000");48;2;$(hex_color_to_rgb "$main")m\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main")m" ;;
        ab) printf "\033[0m\033[38;2;$(hex_color_to_rgb "000000");48;2;$(hex_color_to_rgb "$main")m\033[38;2;$(hex_color_to_rgb "$accent");48;2;$(hex_color_to_rgb "$main");1m" ;;
        f)  printf "\033[0m\033[38;2;$(hex_color_to_rgb "$main")m" ;;
        s)  printf "\033[0m" ;;
    esac
}

### ───────────────────────────────
###  SEASON + TIME DETECTION
### ───────────────────────────────

get_current_palette_name() {
    local month=$(date +%m)
    local hour=$(date +%H)
    local season tod

    # Determine season
    case $month in
        03|04|05) season="SPRING" ;;
        06|07|08) season="SUMMER" ;;
        09|10|11) season="AUTUMN" ;;
        12|01|02) season="WINTER" ;;
    esac

    # Determine time of day
    if [ "$hour" -lt 12 ]; then
        tod="MORNING"
    elif [ "$hour" -lt 17 ]; then
        tod="AFTERNOON"
    else
        tod="EVENING"
    fi

    echo "${season}_${tod}"
}

### ───────────────────────────────
###  PALETTE MANAGEMENT
### ───────────────────────────────

PALETTE_FILE="$HOME/.bash_palettes"
DEFAULT_PALETTE="DEFAULT"

load_palette() {
    local current_name
    current_name=$(get_current_palette_name)

    # Manual override
    if [ -n "$FORCE_PALETTE" ]; then
        current_name="$FORCE_PALETTE"
    fi

    local selection=""
    if [ -f "$PALETTE_FILE" ]; then
        selection=$(grep "^${current_name}=" "$PALETTE_FILE" | head -n1)
    fi

    if [ -z "$selection" ]; then
        echo "[.bash_prompt] Palette '${current_name}' not found, using DEFAULT."
        selection=$(grep "^${DEFAULT_PALETTE}=" "$PALETTE_FILE" | head -n1)
    fi

    local palette_values
    palette_values=$(echo "$selection" | cut -d'=' -f2 | tr -d '"')
    IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"

    export col_1 col_2 col_3 col_4
    export CURRENT_PALETTE="$current_name"
}

### ───────────────────────────────
###  COMMANDS (d, ff, ffpick, ffshow)
### ───────────────────────────────

# Reset to default palette
d() {
    export FORCE_PALETTE="DEFAULT"
    source ~/.bash_prompt
}

# Random (season/time) palette
ff() {
    unset FORCE_PALETTE
    unset col_1 col_2 col_3 col_4

    local file="$PALETTE_FILE"
    if [ ! -f "$file" ]; then
        echo "No palette file found at $file"
        return 1
    fi

    # Pick a random non-comment palette name
    local selection
    selection=$(grep -v '^#' "$file" | grep '=' | shuf -n 1)
    local name
    name=$(echo "$selection" | cut -d'=' -f1)
    local palette_values
    palette_values=$(echo "$selection" | cut -d'=' -f2 | tr -d '"')

    IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"

    export FORCE_PALETTE="$name"
    export col_1 col_2 col_3 col_4

    prompt_cmd
}

# Pick and activate a specific palette
ffpick() {
    local target="$1"
    local file="$PALETTE_FILE"
    if [ -z "$target" ]; then
        echo "Usage: ffpick <PALETTE_NAME>"
        return 1
    fi
    local line
    line=$(grep "^${target}=" "$file" 2>/dev/null)
    if [ -z "$line" ]; then
        echo "Palette '$target' not found."
        return 1
    fi

    local palette_values
    palette_values=$(echo "$line" | cut -d'=' -f2 | tr -d '"')
    IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"

    export FORCE_PALETTE="$target"
    export col_1 col_2 col_3 col_4
    source ~/.bash_prompt
}

# Preview all palettes as mini prompts
ffshow() {
    local file="$PALETTE_FILE"
    if [ ! -f "$file" ]; then
        echo "No palette file found at $file"
        return 1
    fi

    local original_col_1=$col_1
    local original_col_2=$col_2
    local original_col_3=$col_3
    local original_col_4=$col_4

    local preview_env="${ENV:-☕ LOCAL}"
    local preview_conda="conda_env"
    local preview_shortpwd="~/p/bash"
    local preview_branch="main"

    while IFS='=' read -r name value; do
        [[ "$name" =~ ^#|^$ ]] && continue
        name=$(echo "$name" | xargs)
        local palette_values
        palette_values=$(echo "$value" | tr -d '"')
        IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"

        local LINE_1 LINE_2
        LINE_1="$(rgb_raw $col_1 'f')╭──$(rgb_raw $col_1 'u') ::$preview_conda:: $(rgb_raw $col_1 'f')\
$(rgb_raw $col_2 'ab') $preview_env $(rgb_raw $col_2 'f')\
$(rgb_raw $col_3 'a') $preview_shortpwd $(rgb_raw $col_3 'f')\
$(rgb_raw $col_4 'a')  $preview_branch $(rgb_raw 's')"
        LINE_2="$(rgb_raw $col_1 'f')╰─ >>> $(rgb_raw 's')"

        echo -e "${LINE_1}\n${LINE_2}   [$name]\033[0m"
    done < "$file"

    # Restore original palette
    export col_1=$original_col_1
    export col_2=$original_col_2
    export col_3=$original_col_3
    export col_4=$original_col_4
    echo -e "\033[0m"
}

### ───────────────────────────────
###  INITIAL PALETTE LOAD
### ───────────────────────────────

if [ -n "$FORCE_PALETTE" ]; then
    selection=$(grep "^${FORCE_PALETTE}=" "$PALETTE_FILE" | head -n1)
    palette_values=$(echo "$selection" | cut -d'=' -f2 | tr -d '"')
    IFS='|' read -r col_1 col_2 col_3 col_4 <<< "$palette_values"
else
    load_palette
fi

### ───────────────────────────────
###  PROMPT CONSTRUCTION
### ───────────────────────────────

prompt_cmd() {
    local GIT_BRANCH="$(git branch --show-current 2>/dev/null)"
    local CONDA_ENV="$(echo $CONDA_DEFAULT_ENV | awk -F '/' '{print $NF}')"

    # Git dirty check
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        git diff --quiet 2>/dev/null || GIT_DIRTY="*"
    else
        GIT_DIRTY=""
    fi

    local SHORT_PWD="$(echo ${PWD%\/*} | sed -r 's|/(..)[^/]*|/\1|g')"
    local CURRENT_DIR="$(echo ${PWD##*/})"

    if [ -n "$STY" ]; then
        LINE_1="╭── ::$CONDA_ENV:: | $ENV | $PWD"
        LINE_2="╰─ >>> "
        [ -n "$GIT_BRANCH" ] && LINE_1="$LINE_1 |  $GIT_BRANCH$GIT_DIRTY"
        PS1="\r\n${LINE_1}\r\n${LINE_2}"
        return
    fi

    LINE_1="$(rgb_ps1 $col_1 'f')╭──$(rgb_ps1 $col_1 'u') ::$CONDA_ENV:: $(rgb_ps1 $col_1 'f')\
$(rgb_ps1 $col_2 'ab') $ENV $(rgb_ps1 $col_2 'f')\
$(rgb_ps1 $col_3 'a') $SHORT_PWD/$CURRENT_DIR $(rgb_ps1 $col_3 'f')"

    if [ -n "$GIT_BRANCH" ]; then
        LINE_1="$LINE_1$(rgb_ps1 $col_4 'a')  $GIT_BRANCH$GIT_DIRTY $(rgb_ps1 's')"
    else
        LINE_1="$LINE_1$(rgb_ps1 's')"
    fi

    LINE_2="$(rgb_ps1 $col_1 'f')╰─ >>> $(rgb_ps1 's')"

    PS1="\r\n${LINE_1}\r\n${LINE_2}\[\033[0m\]"
}

export PROMPT_COMMAND='prompt_cmd'

